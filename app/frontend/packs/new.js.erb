// import geocoder library
import geocoder from 'geocoder'
// import leaflet's marker-pictures
import marker_icon_2x from 'leaflet/dist/images/marker-icon-2x.png'
import marker_icon from 'leaflet/dist/images/marker-icon.png'
import marker_shadow from 'leaflet/dist/images/marker-shadow.png'

const PICTURE_ERRORS_CLASS = 'has-errors';
// Get API key from enviropment
const API_GEOCODE_KEY = '<%= ENV['API_GOOGLE_GEOCODE'] %>';

let latlng = [0.0, 0.0];
let zoom = 5;
let country = '';
let marker;

// Get address fields
let country_field = document.getElementById('place_address_attributes_country');
let state_region_field = document.getElementById('place_address_attributes_state_region');
let city_field = document.getElementById('place_address_attributes_city');
let street_field = document.getElementById('place_address_attributes_details');
let number_street_field = document.getElementById('place_address_attributes_details');
//Get container with errors
let image_errors = document.getElementById('image-error');
let picture_label = document.getElementById('place_pictures_label');
let map_container = document.getElementById('map');
let map_text_error = document.getElementById('map-error');
let place_lon = document.getElementById('place_lon');
let place_lat = document.getElementById('place_lat')
// Marker add and delete function
function markerAdd(lat, lng) {
  if (marker) marker.remove();
  marker = L.marker([lat, lng])
    .addTo(map);

  marker.on('click', evt => {
    // Removing marker
    marker.remove()

    // Clearing latitude and longitude fields
    document.getElementById('place_lon').value = '';
    document.getElementById('place_lat').value = '';

    // Clearing address's fields
    state_region_field.value = '';
    city_field.value = '';
    street_field.value = '';
  });
};


delete L.Icon.Default.prototype._getIconUrl;    //**************************
                                                //*
L.Icon.Default.mergeOptions({                   //* Resolved bug
  iconRetinaUrl: marker_icon_2x,                //* with
  iconUrl: marker_icon,                         //* loading images
  shadowUrl: marker_shadow,                     //*
});                                             //**************************

if (image_errors.textContent.length > 0) {
  picture_label.className = 'has-errors';
} else {
  picture_label.className = '';
}

if (localStorage.getItem('newplace-map-location')) {
  latlng = JSON.parse(localStorage.getItem('newplace-map-location'));
}

let map = L.map('map').setView(latlng, 10);

L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?' +
            'access_token={accessToken}', {
  maxZoom: 18,
  id: 'mapbox/streets-v11',
  tileSize: 512,
  zoomOffset: -1,
  accessToken: '<%= ENV["MAPBOX_API_KEY"] %>'
}).addTo(map);

// When user click on map
map.on('click', evt => {
  let { lat, lng } = evt.latlng;

  // Fill in latitude and longitude fields
  place_lon.value = lng;
  place_lat.value = lat;

  // Reverse geocoding
  geocoder.reverseGeocode(lat, lng, function ( err, data ) {
    let parts = data.results[0].address_components.reverse();
    parts.forEach((part) => {
      // Fill in country field
      if (part.types.includes('country')) {
        country_field.value = part.short_name;
      };

      // Fill in city field
      if (part.types.includes('administrative_area_level_1')) {
        state_region_field.value = part.long_name;
      };

      // Fill in state or region field
      if (part.types.includes('locality') || part.types.includes('administrative_area_level_2')) {
        city_field.value = part.long_name;
      };

      // Fill in details as street field
      if (part.types.includes('route')) {
        street_field.value = part.long_name;
      };

      // Fill in details as street number field
      if (part.types.includes('street_number')) {
        number_street_field.value += `, ${ part.long_name }`;
      };
    });

  }, { key: API_GEOCODE_KEY });         //api key

  localStorage.setItem('newplace-map-location', JSON.stringify([lat,lng]));

  markerAdd(lat, lng)
});

//When user write address in fields
document.getElementById('address_form').addEventListener('change', () => {  // or event 'input' for geocoding in real time
  // Get full country name
  [...Array(country_field.length).keys()].forEach((i) => {
    if (country_field[i].value == country_field.value) {
      country = country_field[i].text;
      return;
    }
  });

  let address_string = `${ country }, ${ city_field.value }, ` +
                       `${ state_region_field.value }, ` +
                       `${ street_field.value }, ` +
                       `${ number_street_field.value }`;

  zoom = 5;
  // Setting zoom value by filling fields
  if (state_region_field.value.length != 0 && street_field.value != ' ') {
    zoom = 10;
  };

  if (city_field.value.length != 0 && street_field.value != ' ') {
    zoom = 14;
  };

  if (street_field.value.length != 0 && street_field.value != ' ') {
    zoom = 16;
  } else {
    // It remove marker if street field is empty
    if (marker) marker.remove();
  };

  if (street_field.value.length != 0 && number_street_field.value.includes(',')) {
    zoom = 18;
  };

  // Geocoding by address from fields
  geocoder.geocode(address_string, function ( err, data ) {
    if (data.results[0]) {
      let { lat, lng } = data.results[0].geometry.location;

      // Fill in latitude and longitude fields
      place_lon.value = lng;
      place_lat.value = lat;

      if (map_container.classList.contains(PICTURE_ERRORS_CLASS)) {
        map_container.classList.remove(PICTURE_ERRORS_CLASS);
        map_text_error.textContent = '';
      }

      // Moving to selected address
      map.flyTo([lat, lng], zoom);
      if (street_field.value.length != 0 && street_field.value != ' ' && number_street_field.value.includes(',')) {
        markerAdd(lat, lng);
      };
    } else {
      map_container.classList.add(PICTURE_ERRORS_CLASS);
      map_text_error.textContent = 'Address Not Found';
    }
  }, { key: API_GEOCODE_KEY });         //api key
});
